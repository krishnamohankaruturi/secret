package edu.ku.cete.domain.validation;

import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeanWrapperImpl;

import edu.ku.cete.domain.property.ContainsKeyValuePairs;
import edu.ku.cete.domain.property.ValidateableRecord;
import edu.ku.cete.util.AartParseException;
import edu.ku.cete.util.CommonConstants;
import edu.ku.cete.util.DateUtil;
import edu.ku.cete.util.NumericUtil;
import edu.ku.cete.util.ParsingConstants;
import edu.ku.cete.util.StringUtil;

/**
 * Validation for any given irrespective of data type of field.
 * This is persisted in the table.
 * @author m802r921
 * @version 1.0
 * @updated 10-May-2012 5:53:26 PM
 */
public class FieldSpecification implements Serializable{
    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database column public.field_specification.id
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    private Long id;
    /**
	 * name of the attribute in the upload or webservice.
	 */
    private String mappedName;
    /**
	 * name of the attribute in the bean.
	 */
    private String fieldName;

    /**
	 * for all fields.
	 */
    private String[] allowableValues;

    /**
	 * for numeric fields.
	 */
    private Long minimum;
    
    private String minimumRegex;
    
    private String maximumRegex;
    
    private String regexModeFlags;
    
    private Boolean required;
    
    private String jsonData;
    
    private Integer sortOrder;

    /**
	 * for numeric fields.
	 */
    private Long maximum;

    /**
	 * length for text fields.
	 */
    private Integer fieldLength;
    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database column public.field_specification.reject_if_empty
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    private boolean rejectIfEmpty;
    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database column public.field_specification.reject_if_empty
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    private boolean showError;

    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database column public.field_specification.reject_if_invalid
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    private boolean rejectIfInvalid;
	/**
	 * regular expression like email addresses.
	 */
	private String formatRegex;
	/**
	 * doReject.
	 */
	private boolean doReject;
	/**
	 * if true it indicates that the field needs to be set based of key value property.
	 */
	private boolean isKeyValuePairField;
	/**
	 * This is more than a dummy object it validates the fields so adding logger. 
	 */
	private static final Log LOGGER = LogFactory.getLog(FieldSpecification.class);
	
	private String fieldType;
    /**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.id
     *
     * @return the value of public.field_specification.id
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public Long getId() {
        return id;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.id
     *
     * @param id the value for public.field_specification.id
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public void setId(Long id) {
        this.id = id;
    }

    /**
	 * @return the mappedName
	 */
	public String getMappedName() {
		return mappedName;
	}

	/**
	 * @param mappedName the mappedName to set
	 */
	public void setMappedName(String mappedName) {
		this.mappedName = mappedName;
	}

	/**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.field_name
     *
     * @return the value of public.field_specification.field_name
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public String getFieldName() {
        return fieldName;
    }
    
    public String getMinimumRegex() {
		return minimumRegex;
	}

	public void setMinimumRegex(String minimumRegex) {
		this.minimumRegex = minimumRegex;
	}

	public String getMaximumRegex() {
		return maximumRegex;
	}

	public void setMaximumRegex(String maximumRegex) {
		this.maximumRegex = maximumRegex;
	}

	public String getRegexModeFlags() {
		return regexModeFlags;
	}

	public void setRegexModeFlags(String regexModeFlags) {
		this.regexModeFlags = regexModeFlags;
	}

	public void setRequired(Boolean required) {
		this.required = required;
	}
	
	public Boolean isRequired() {
		return Boolean.TRUE.equals(this.required);
	}
	
	// helper, just for readability
	public Boolean isOptional() {
		return !isRequired();
	}

	public String getJsonData() {
		return jsonData;
	}

	public void setJsonData(String jsonData) {
		this.jsonData = jsonData;
	}

	public Integer getSortOrder() {
		return sortOrder;
	}

	public void setSortOrder(Integer sortOrder) {
		this.sortOrder = sortOrder;
	}

	/**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.field_name
     *
     * @param fieldName the value for public.field_specification.field_name
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public void setFieldName(String fieldName) {
        this.fieldName = fieldName == null ? null : fieldName.trim();
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.allowable_values
     *
     * @return the value of public.field_specification.allowable_values
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public String[] getAllowableValuesArray() {
        return allowableValues;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.allowable_values
     *
     * @param allowableValues the value for public.field_specification.allowable_values
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public void setAllowableValuesArray(String[] allowableValues) {
        this.allowableValues = allowableValues;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.allowable_values
     *
     * @return the value of public.field_specification.allowable_values
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public Object getAllowableValues() {
        return allowableValues;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.allowable_values
     *
     * @param allowValues the value for public.field_specification.allowable_values
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public final void setAllowableValues(Object allowValues) {
    	String allowableValuesStr = ParsingConstants.BLANK + allowValues;
		if (StringUtils.isNotEmpty(allowableValuesStr)) {
			//TODO update in DB to contain only lower case values.
			// if needed add a column for case insensitive comparison
			allowableValuesStr = allowableValuesStr.trim().toLowerCase();
			allowableValuesStr = allowableValuesStr.substring(1,
					allowableValuesStr.length() - 1);
			if (StringUtils.isNotEmpty(allowableValuesStr)) {
				//TODO to handle blank strings
				//allowableValuesStr = allowableValuesStr.replaceAll("'", "");
				this.allowableValues = allowableValuesStr
						.split(ParsingConstants.OUTER_DELIM);
				if (this.allowableValues != null && this.allowableValues.length > 0 &&
						allowableValuesStr.indexOf(ParsingConstants.QUOTE_BLANK_SPACE) >= 0) {
					//add a blank string
					int oldLength = this.allowableValues.length;
					this.allowableValues = Arrays.copyOf(this.allowableValues,
							(oldLength + 1));
					this.allowableValues[oldLength] = ParsingConstants.BLANK;
				}
			}
		}
    }
    /**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.minimum
     *
     * @return the value of public.field_specification.minimum
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public Long getMinimum() {
        return minimum;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.minimum
     *
     * @param minimum the value for public.field_specification.minimum
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public void setMinimum(Long minimum) {
        this.minimum = minimum;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.maximum
     *
     * @return the value of public.field_specification.maximum
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public Long getMaximum() {
        return maximum;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.maximum
     *
     * @param maximum the value for public.field_specification.maximum
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public void setMaximum(Long maximum) {
        this.maximum = maximum;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.field_length
     *
     * @return the value of public.field_specification.field_length
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public Integer getFieldLength() {
        return fieldLength;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.field_length
     *
     * @param fieldLength the value for public.field_specification.field_length
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public void setFieldLength(Integer fieldLength) {
        this.fieldLength = fieldLength;
    }

    /**
	 * @return the formatRegex
	 */
	public String getFormatRegex() {
		return formatRegex;
	}

	/**
	 * @param formatRegex the formatRegex to set
	 */
	public void setFormatRegex(String formatRegex) {
		this.formatRegex = formatRegex;
	}
	/**
	 * @return the showError
	 */
	public boolean isShowError() {
		return showError;
	}

	/**
	 * @param showError the showError to set
	 */
	public void setShowError(boolean showError) {
		this.showError = showError;
	}

	/**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.reject_if_empty
     *
     * @return the value of public.field_specification.reject_if_empty
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public Boolean getRejectIfEmpty() {
        return rejectIfEmpty;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.reject_if_empty
     *
     * @param rejectIfEmpty the value for public.field_specification.reject_if_empty
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public void setRejectIfEmpty(Boolean rejectIfEmpty) {
        this.rejectIfEmpty = rejectIfEmpty;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method returns the value of the database column public.field_specification.reject_if_invalid
     *
     * @return the value of public.field_specification.reject_if_invalid
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public Boolean getRejectIfInvalid() {
        return rejectIfInvalid;
    }

    /**
     * This method was generated by MyBatis Generator.
     * This method sets the value of the database column public.field_specification.reject_if_invalid
     *
     * @param rejectIfInvalid the value for public.field_specification.reject_if_invalid
     *
     * @mbggenerated Thu May 10 16:05:01 CDT 2012
     */
    public void setRejectIfInvalid(Boolean rejectIfInvalid) {
        this.rejectIfInvalid = rejectIfInvalid;
    }
	/**
	 * @return the doReject
	 */
	public boolean isDoReject() {
		return doReject;
	}

	/**
	 * @param doReject the doReject to set
	 */
	public void setDoReject(boolean doReject) {
		this.doReject = doReject;
	}

	/**
	 * @return the isKeyValuePairField
	 */
	public final boolean isKeyValuePairField() {
		return isKeyValuePairField;
	}

	/**
	 * @param isKeyValuePairField the isKeyValuePairField to set
	 */
	public final void setKeyValuePairField(boolean isKeyValuePairField) {
		this.isKeyValuePairField = isKeyValuePairField;
	}
	
	public String getFieldType() {
		return fieldType;
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	/**
	 * Generates the list of invalid details object.
	 * 
	 * 1) Check if any of the existing (if it exists) inValidDetails list is for the
	 * inValue being passed.If yes then return existing inValidDetail list.If no
	 * follow steps below,
	 * 2) Checks if the value is valid.Adds to invalid details.
	 * 3) checks if the value is empty.Adds to invalid details.
	 * 4) Performs the type conversion by invoking the setter by using bean wrapper
	 * object.
	 * 5) if type conversion fails adds to InValidDetails
	 * 6) Checks the length and if fails adds to Invalid Details
	 * 7) if rejectIfEmpty flag is set and the invalid type is empty then reject is
	 * set to true.
	 * 8) if rejectIfInvalid flag is set and the invalid type is invalid then reject
	 * is set to true.
	 * 9) adds the invalid details to the passed object.
	 *  TODO remove multiple returns.
	 * @param bean
	 * @param inValue
	 */
	public void validate(Object bean, String inValue) {
		boolean inValid = false;
		if (showError) {
			//if no need to show error no need to validate.
			inValid = validateNonEmpty(bean, inValue);
			//if any field is invalid for more than one reason, then find only the first reason.
			if (inValid) {
				validateTypeAndSet(bean, inValue, false);
				return;
			}
			//No need to do null check because validate not empty is already complete.
			inValue = inValue.trim();
			inValid = validateLength(bean, inValue);
			if (inValid) {
				
				inValue = StringUtil.parse(inValue, this.fieldLength.intValue());
				validateTypeAndSet(bean, inValue, false);
				return;
			}
			
			inValid = validateAllowableValues(bean, inValue);
			if (inValid) {
				validateTypeAndSet(bean, inValue, false);
				return;
			}
			
			inValid = validateRegex(bean, inValue);
			if (inValid) {
				validateTypeAndSet(bean, inValue, false);
				return;
			}
			
			inValid = validateRange(bean, inValue);
			if (inValid) {
				validateTypeAndSet(bean, inValue, false);
				return;
			}
		}
		inValid = validateTypeAndSet(bean, inValue, true);
	}		

	/**
	 * This does the same validation as validate(Object bean, String inValue)
	 * and the only difference is, the below method would be used for validating the
	 * horizontal csv file with attributeName and attributeValue (key, value) pairs. 
	 *  
	 * @param bean
	 * @param inAttribute
	 * @param inValue
	 */
	public void validateAttribute(Object bean, String inAttribute, String inValue) {
		boolean inValid = false;
		if (showError) {
			//if no need to show error no need to validate.
			inValid = validateNonEmpty(bean, inValue);
			//if any field is invalid for more than one reason, then find only the first reason.
			if (inValid) {
				validateAttributeTypeAndSet(bean, inAttribute, inValue, false);
				return;
			}
			//No need to do null check because validate not empty is already complete.
			inValue = inValue.trim();
			inValid = validateLength(bean, inValue);
			if (inValid) {
				//trim the invalue to the right field so that it will not fail on insert.
				inValue = StringUtil.parse(inValue, this.fieldLength.intValue());
				validateAttributeTypeAndSet(bean, inAttribute, inValue, false);
				return;
			}
			
			inValid = validateAllowableValues(bean, inValue);
			if (inValid) {
				validateAttributeTypeAndSet(bean, inAttribute, inValue, false);
				return;
			}
			
			inValid = validateRegex(bean, inValue);
			if (inValid) {
				validateAttributeTypeAndSet(bean, inAttribute, inValue, false);
				return;
			}
			
			inValid = validateRange(bean, inValue);
			if (inValid) {
				validateAttributeTypeAndSet(bean, inAttribute, inValue, false);
				return;
			}
		}
		inValid = validateAttributeTypeAndSet(bean, inAttribute, inValue, true);
	}
	
	/**
	 * 1) Generates the invalid detail object.
	 * 2) Checks if the value is one of the allowed values (if it exists). If not Adds
	 * to invalid details.
	 * 3) if rejectIfInvalid flag is set then reject is set to true.
	 * 4) adds the invalid details to the passed object.
	 * 
	 * @param bean
	 * @param inValue
	 */
	private boolean validateAllowableValues(Object bean, String inValue) {
		if (ArrayUtils.isNotEmpty(this.allowableValues)) {
			if (ArrayUtils.contains(this.allowableValues, inValue.toLowerCase())) {
				return false;
			} else {
				addInvalidField(bean, inValue, rejectIfInvalid, " is not a valid value of either " + StringUtils.join(this.allowableValues,",") + ".");
				return true;
			}
		}
		return false;
	}

	/**
	 * add to the invalid details on the object.
	 * sets the flag on field spec object.
	 * If show error is set for all fields in the record,then the record will never be rejected
	 * @param bean {@link Object}
	 * @param inValue {@link String}
	 * @param reject {@link Boolean}
	 */
	private void addInvalidField(Object bean, String inValue,
			boolean reject) {
		if(mappedName != null && StringUtils.isNotEmpty(mappedName)) {
			((ValidateableRecord) bean).addInvalidField(mappedName, inValue, reject);
		} else {
			((ValidateableRecord) bean).addInvalidField(fieldName, inValue, reject);
		}
	}
	
	/**
	 * 
	 * @param bean
	 * @param inValue
	 * @param reject
	 * @param reason
	 */
	private void addInvalidField(Object bean, String inValue,
			boolean reject, String reason) {
		if(mappedName != null && StringUtils.isNotEmpty(mappedName)) {
			((ValidateableRecord) bean).addInvalidField(mappedName, inValue, reject, reason);
		} else {
			((ValidateableRecord) bean).addInvalidField(fieldName, inValue, reject, reason);
		}
	}

	/**
	 * To be called after type conversion succeeded.
	 * 1) Generates the invalid detail object.
	 * 2) Checks if the value is with in the given minimum and maximum (if it exists) .
	 * If not Adds to invalid details.
	 * 3) if rejectIfInvalid flag is set then reject is set to true.
	 * 4) adds the invalid details to the passed object.
	 *
	 * @param bean {@link Object}
	 * @param inValue {@link String}
	 * @return {@link Boolean}
	 */
	private boolean validateRange(Object bean, String inValue) {
		//if valid range is set validate.
		if (NumericUtil.validateRange(this.maximum, this.minimum)) {
			if (NumericUtil.isAllowed(minimum, maximum, inValue)) {
				return false;
			} else {
				this.addInvalidField(bean, inValue, rejectIfInvalid, " must contain "+this.minimum + " - " + this.maximum + ".");
				return true;
			}
		}
		return false;
	}
	/**
	 * 1) Generates the invalid detail object.
	 * 2) Checks if the value is empty.
	 * 3) if empty is allowed then a valid value.
	 * 4) if empty is not allowed then an invalid value.
	 * 5) if empty and there are not allowable values , then an invalid value.
	 * 6) if rejectIfInvalid flag is set then reject is set to true.
	 * 7) adds the invalid details to the passed object.
	 * 
	 * @param bean {@link Object}
	 * @param inValue {@link String}
	 * @return {@link Boolean}
	 */
	private boolean validateNonEmpty(Object bean, String inValue) {
		if (StringUtils.isEmpty(inValue)) {
			if (ArrayUtils.isNotEmpty(this.allowableValues)) {
				if (ArrayUtils.contains(this.allowableValues, inValue)) {
					return false;
				} else {
					addInvalidField(bean, inValue, rejectIfEmpty, "is not a valid value of either " + StringUtils.join(this.allowableValues,",") + ".");
					return true;
				}
			}
			//check the regex to see if the regex allows empty values.
			if (StringUtils.isNotEmpty(this.formatRegex)) {
				//check if inValue is not null.It should not be null to do regex validation.
				Pattern regexPattern = Pattern.compile(formatRegex);
				Matcher regexMatcher = regexPattern.matcher(inValue);
				//if it matches then blank is allowed in the regex.
				if (regexMatcher.matches()) {
					return false;
				} else {
					//if empty add an invalid field for the field being empty.
					this.addInvalidField(bean, inValue, rejectIfEmpty, " is required and is blank.");
					return true;
				}
			} 
			//check if empty is allowed
			if(this.rejectIfEmpty){
				addInvalidField(bean, inValue, rejectIfEmpty, " is required and is blank.");
				return true;
			}
		}
		return false;
	}
	/**
	 * 1) Generates the invalid detail object.
	 * 2) Checks if the value satisfies the length (if it exists) . If not Adds to
	 * invalid details.
	 * 3) if rejectIfInvalid flag is set then reject is set to true.
	 * 4) adds the invalid details to the passed object.
	 * 
	 * @param bean {@link Object}
	 * @param inValue {@link String}
	 * @return {@link Boolean}
	 */
	private boolean validateLength(Object bean, String inValue) {
		if (StringUtils.isEmpty(inValue)) {
			if (rejectIfEmpty) {
				//all empty fields are invalid.No
				//If empty is one of the allowable values or there are no allowable values
				//then it is not an invalid field.
				this.addInvalidField(bean, inValue, rejectIfEmpty, " is a required field and is blank.");
				return true;
			}
		}
		//validate if proper field length is set.
		if (this.fieldLength != null && this.fieldLength.intValue() > 0) {
			if (StringUtil.isValid(inValue, this.fieldLength.intValue())) {
				//the passed string is valid.
				return false;
			} else {
				//the passed string is invalid.
				this.addInvalidField(bean, inValue, rejectIfInvalid, " is longer than the maximum length of " + this.fieldLength+".");
				return true;
			}
		}
		return false;
	}

	/**
	 * 1) Generates the invalid detail object.
	 * 2) Checks if the value is with in the given length (if it exists) . If not Adds
	 * to invalid details.
	 * 3) if rejectIfInvalid flag is set then reject is set to true.
	 * 4) adds the invalid details to the passed object.
	 *
	 * @param bean {@link Object}
	 * @param inValue {@link String}
	 * @return {@link Boolean}
	 */
	private boolean validateRegex(Object bean, String inValue) {
		boolean result = true;
		//check if regex format is set.
		if (StringUtils.isNotEmpty(this.formatRegex)) {
			try {
				//check if inValue is not null.It should not be null to do regex validation.
				Pattern regexPattern = Pattern.compile(formatRegex);
				Matcher regexMatcher = regexPattern.matcher(inValue);
				if (regexMatcher.matches()) {
					//passed regex so invalid is false.
					result = false;
				} else {
					if(formatRegex.equals("(0?[1-9]|1[012])(/|-)(0?[1-9]|[12][0-9]|3[01])(/|-)(19|20)?[0-9][0-9]") | formatRegex.equals("(0?[1-9]|1[012])(/|-)(0?[1-9]|[12][0-9]|3[01])(/|-)(19|20)?[0-9][0-9]|^$"))
						this.addInvalidField(bean, inValue, rejectIfInvalid, " is not valid. Date does not match the required date format of MM/DD/YYYY");
					else 
						this.addInvalidField(bean, inValue, rejectIfInvalid, " is not valid.");
				}
			} catch (Exception e) {
				LOGGER.error("Error in regex", e);
				//Do the safest thing. reject the record or state it is invalid.
				this.addInvalidField(bean, inValue, rejectIfInvalid, " is not valid.");
			}
		} else {
			//regex validation does not apply for this field.
			result = false;
		}
		return result;
	}

	/**
	 * 1) Generates the invalid detail object.
	 * 2) Checks if the value is of the same type as that of the write method. If not
	 * Adds to invalid details.
	 * 3) if rejectIfInvalid flag is set then reject is set to true.
	 * 4) adds the invalid details to the passed object.
	 *
	 * @param bean {@link Object}
	 * @param inValue {@link String}
	 * @param addError {@link Boolean}
	 * @return {@link Boolean}
	 */
	public final boolean validateTypeAndSet(Object bean, String inValue, boolean addError) {
		BeanWrapperImpl beanImpl = new BeanWrapperImpl(bean);
		try {
			if(isKeyValuePairField) {
				List<String> keyValuePairs = new ArrayList<String>();
				keyValuePairs.add(mappedName);
				keyValuePairs.add(inValue);
		        beanImpl.setPropertyValue("keyValuePairs", keyValuePairs);
			} else {
				//TODO instead of this find the return type of the getter and then do this validation.
				if (!fieldName.equals("exitDate") && (fieldName.contains("date") || fieldName.contains("Date"))) {
					//TODO as of only one date format is handled.May need to change the regex to hold multiple regexes
					//to check for auto conversion of dates.
					if(StringUtils.isEmpty(inValue) && rejectIfEmpty) {
						if (addError) {
							this.addInvalidField(bean, inValue, rejectIfEmpty, " is required and is blank.");
						}
						return false;
					} else if(StringUtils.isEmpty(inValue)){
						return true;
					}
					
					try{
						DateUtil.newParseAndFail(inValue);
					}catch(AartParseException ape){
						//check 2 digit year format
						DateUtil.parseAndFail(inValue, "MM/dd/yy");
					}
			        
			        if (fieldName.equals("schoolEntryDate") || fieldName.equals("districtEntryDate") || fieldName.equals("exitWithdrawalDate")) {
			        	beanImpl.setPropertyValue(fieldName, DateUtil.convertStringDatetoSpecificTimeZoneDateFormat(inValue, "US/Central",  "MM/dd/yyyy hh:mm:ss a").toString());
			        }else{
			        	beanImpl.setPropertyValue(fieldName, inValue);
			        }
			       
				} else if (StringUtils.isNotEmpty(inValue)) {
			        beanImpl.setPropertyValue(fieldName, inValue);
			        return false;
			    }				
			}
		} catch (Exception e) {
			if (addError) {
				this.addInvalidField(bean, inValue + " is of invalid type.", rejectIfInvalid);
			}
			return true;
		}
		return false;
	}
	
	/**
	 * Sets the values for the bean with corresponding attribute name into attributeName. 
	 * @param bean
	 * @param inAttribute
	 * @param inValue
	 * @param addError
	 * @return
	 */
	public final boolean validateAttributeTypeAndSet(Object bean, String inAttribute, String inValue, boolean addError) {
		BeanWrapperImpl beanImpl = new BeanWrapperImpl(bean);
		beanImpl.setPropertyValue(CommonConstants.CSV_VERTICLE_RECORDS_COLUMNS_HEADER_ATTRIBUTE_NAME, inAttribute);						      
		beanImpl.setPropertyValue(CommonConstants.CSV_VERTICLE_RECORDS_COLUMNS_HEADER_ATTRIBUTE_VALUE, inValue);
		return false;
	}
	
	@Override
	public String toString() {
		return "FieldSpecification [id=" + id + ", mappedName=" + mappedName
				+ ", fieldName=" + fieldName + ", allowableValues="
				+ Arrays.toString(allowableValues) + ", minimum=" + minimum
				+ ", maximum=" + maximum + ", fieldLength=" + fieldLength
				+ ", rejectIfEmpty=" + rejectIfEmpty + ", showError="
				+ showError + ", rejectIfInvalid=" + rejectIfInvalid
				+ ", formatRegex=" + formatRegex + ", doReject=" + doReject
				+ "]";
	}
	
}